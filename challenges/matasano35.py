#matasano 5.35
 
import random
import binascii
import os
from matasano10 import aes_cbc_decrypt, aes_cbc_encrypt
from matasano28 import sha1
from matasano18 import bi2ba
from matasano34 import netsim

    
if __name__ == '__main__':
    '''35; some slight deltas.
    Didnt put in an ACK, seems to have no significance
    here.
    Noted that the attacks on g only, of course, allow
    decryption of the message generated by the side with
    the non-fake g (because A^b, B^a). They also raise
    decryption errors for the other side. But the attacker
    does get decrypted messages from one side.
    
    Whereas the challenge 34 attack, on the
    pubkeys, allow decryption of both directions. For some
    reason the challenge specifies sending the *same* 
    message back and forth, which seems silly. But, minor
    detail.'''
    
    g = 2
    pstr = """
    ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024
    e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd
    3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec
    6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f
    24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361
    c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552
    bb9ed529077096966d670c354e4abc9804f1746c08ca237327fff
    fffffffffffff
    """
    p = long(eval('0x'+''.join(pstr.split())))
    
    #Implementing 3 separate attacks; 1, set g = 1,
    #2, set g = p,
    #3, set g = p -1
    #In each case, concoct a scheme for Mallory to read.
    for mitm in [(None, None),('switch_g_to_1', 1), ('switch_g_to_p', p),
                 ('switch_g_to_p-1', p-1)]:
        #A makes new keypair (a,A) and sends p,g,A to B
        a = random.randint(0,p-1)
        A = pow(g, a, p)
        
        pB = netsim(p, 'key-exchange')
        gB = netsim(g, 'key-exchange', mitm[0], mitm[1])
        AB = netsim(A, 'key-exchange') 
        
        #B makes new keypair (b, B) and sends B to A
        b = random.randint(0, p-1)
        B = pow(gB, b, pB)
        
        BA = netsim(B, 'key-exchange') #MITM sends p instead of B
        
        #A calculates the shared secret s and uses its
        #hash as a key for sending an AES-CBC encrypted message to B
        s = pow(BA, a, p)
        key_A = binascii.unhexlify(sha1(bi2ba(s)))[:16]
        iv_A = os.urandom(16)
        sent_to_B = netsim(aes_cbc_encrypt("This is A for sure", key_A, iv_A), 
                           'enc', MITM_type=mitm[0], MITM_data = p-1)
        
        #B calculates his version of key, reads message
        s2 = pow(AB, b, pB)
        key_B = binascii.unhexlify(sha1(bi2ba(s2)))[:16]
        try:
            received_by_B = aes_cbc_decrypt(sent_to_B, key_B)
            print 'B received: ' + received_by_B
        except ValueError:
            print 'B failed to decrypt; corrupted message?'
        
        #B sends something to A, same story
        iv_B = os.urandom(16)
        sent_to_A = netsim(aes_cbc_encrypt("This is B for sure", key_B, iv_B),
                           'enc')
        try:
            received_by_A = aes_cbc_decrypt(sent_to_A, key_A)
            print 'A received: '+ received_by_A
        except ValueError:
            print 'A failed to decrypt; corrupted message?'
    
        print 'OK for case : '
        print mitm

            